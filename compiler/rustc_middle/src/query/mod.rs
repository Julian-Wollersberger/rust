use crate::ty::TyCtxt;
use rustc_hir::def_id::LocalDefId;

fn describe_as_module(def_id: LocalDefId, tcx: TyCtxt<'_>) -> String {
    if def_id.is_top_level_module() {
        "top-level module".to_string()
    } else {
        format!("module `{}`", tcx.def_path_str(def_id.to_def_id()))
    }
}

// This macro is generated by the proc macro in rustc_query_system.
// But these imports are not available there, so we invoke the macro here in rustc_middle.
rustc_query_system::query_description_stream!{
    use crate::dep_graph::SerializedDepNodeIndex;
    use crate::mir::interpret::{GlobalId, LitToConstInput};
    use crate::traits;
    use crate::traits::query::{
        CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,
        CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,
        CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,
    };
    use crate::ty::query::queries;
    use crate::ty::subst::{GenericArg, SubstsRef};
    use crate::ty::{self, ParamEnvAnd, Ty};
    use rustc_hir::def_id::{CrateNum, DefId};
    use rustc_query_system::query::QueryDescription;

    use rustc_span::symbol::Symbol;
    use std::borrow::Cow;
}
